You are working on an existing, carefully planned ANPR 2.0 project that was generated by Bolt.new and extended with a separate frontend app. Your job is to wire everything up and run it correctly on Replit, without changing the core architecture or auto-creating new infrastructure.

1. High-level goal

Get the backend services and the frontend running reliably on Replit using:

Supabase for Postgres database + auth

External managed Redis (e.g., Upstash Redis) for queues/caching

Use environment variables/secrets for all credentials.

Do not redesign the system, change the database schema, or introduce new services unless explicitly requested.

Treat this repo as production-oriented, not a toy demo.

2. Repo context

The root folder is a Bolt-generated ANPR microservices-style project (backend + workers, etc.).
I have now added a frontend/ folder which contains the Lovable-generated frontend that uses the openapi.yaml API contract from the backend.

Roughly:

Root:

Backend API (likely FastAPI or similar, using openapi.yaml)

Worker(s) / background jobs

Shared libraries

Config files

frontend/:

React (or similar) app

Uses the openapi.yaml to talk to the backend

Uses Ola Maps (keys not added yet)

You may inspect the repo structure, but:

Do not delete or heavily rewrite existing files.

Do not auto-generate a brand-new project on top of this one.

3. What you MUST NOT do

Do not design or create a new database schema.

The schema and migrations already come from the original Bolt project and will be handled via Supabase.

Do not depend on Replit’s auto-created Postgres/Redis unless I explicitly say so.

Replit may have auto-created its own database and Redis when I imported the repo.

These should not be assumed as the primary DB/queue.

If needed, you may keep them unused or disabled; the default should be external Supabase + external Redis.

Do not:

Modify authentication logic beyond what is necessary to read secrets from env variables.

Break API routes that are already aligned with openapi.yaml.

Overwrite or regenerate the openapi.yaml unless I explicitly ask.

Do not hardcode any credentials anywhere in the code.

All secrets must come from Replit Secrets / environment variables only.

4. What you SHOULD do
4.1. Backend runtime setup

Detect the backend entry point (e.g., uvicorn main:app, python -m app.main, or similar) and configure:

A run command for the main API service on some port (e.g., 8000).

If there is a worker service (for queues/background jobs), configure a separate run command for it (e.g., python worker.py or as defined in the repo).

Your tasks here:

Identify:

The main API application file and how it is meant to be started.

Any background/worker services that should be started in parallel.

Set up appropriate Replit Run configuration(s) so I can:

Start the backend API.

Start any workers (if needed).

4.2. Frontend (frontend/) setup

Inside frontend/, detect the framework (likely React + Vite/CRA/Next or similar).

Configure:

npm install / pnpm install as needed.

npm run dev or npm run start for development.

If applicable, build command (npm run build) and serve/preview configuration.

Your tasks here:

Ensure the frontend can run successfully in Replit.

Make sure the frontend is pointing to the correct backend base URL via environment/config (not hardcoded to localhost incorrectly for production).

If you need to change the frontend API base URL, do it via env variables or config files where they are meant to be configured (e.g., VITE_API_BASE_URL, REACT_APP_API_BASE_URL, etc.).

4.3. Environment variables / secrets

All credentials and external services must be wired via Replit secrets.
You must ask me for these values and then assume I will input them into the Replit “Secrets” UI.

Required from me:

Supabase

Ask me for:

SUPABASE_URL

SUPABASE_ANON_KEY

SUPABASE_SERVICE_ROLE_KEY

SUPABASE_DATABASE_URL or DATABASE_URL
(Use whichever name the backend expects; if unclear, inspect the code and tell me the exact expected env var name.)

Use these to:

Configure the backend’s database connection string.

Configure any Supabase client(s) in the backend.

Configure any Supabase usage in the frontend (if present).

Redis (external, e.g., Upstash)

Ask me for:

If using generic Redis:

REDIS_URL (or whatever variable name the backend expects — find it in the code).

If using Upstash-specific vars:

UPSTASH_REDIS_URL

UPSTASH_REDIS_REST_URL

UPSTASH_REDIS_REST_TOKEN

Check the codebase to see which variable names are used. Then:

Tell me exactly which env vars are required.

I will paste the values in Replit secrets.

Maps (Ola Maps)

Ask me for:

OLA_MAPS_API_KEY (or the appropriate key name used in the frontend).

Configure the frontend to read this from env (e.g., VITE_OLA_MAPS_API_KEY or similar) and not hardcode it.

Auth / Security / Misc

Inspect the codebase for any of the following (or equivalents):

JWT_SECRET / JWT_PRIVATE_KEY / JWT_PUBLIC_KEY

SECRET_KEY (for session or crypto)

Any 3rd-party service keys (logging, monitoring, email, etc.)

Then:

List all such required env vars clearly to me.

Wait for me to provide the values.

Ensure the backend and frontend are configured to read them strictly from env.

5. Database & migrations behavior

For Supabase (Postgres):

Assume that:

Schema/migrations are already defined in the repo (e.g., via SQL migrations or Alembic).

Your job is to:

Ensure the backend connects to the Supabase Postgres using DATABASE_URL or equivalent.

Identify any commands to run migrations (if present), e.g., alembic upgrade head or custom scripts.

Ask me:

If I want you to help identify and document the migration command.

Then show me clearly:

Which command to run locally (if needed).

Or how it might integrate with runtime (if the app auto-applies migrations).

Do not design new tables or modify schema assumptions on your own.

6. Queues / workers behavior

If the repo uses Redis for:

Job queues

Background tasks

Caching

Then:

Identify which components expect Redis (e.g., a worker service).

Confirm the environment variable names they use.

Ensure that only the external Redis is wired via these env vars.

Provide clear instructions on:

How to start the worker on Replit.

Whether it must be started separately or alongside the main API.

Do not assume or auto-wire Replit’s own Redis; always default to my external credentials.

7. Networking & ports

Detect the port the backend server runs on (e.g., 8000).

Ensure Replit is configured so that:

The backend listens on the correct host/port.

The frontend’s API base URL matches the backend’s public URL (Replit’s URL or internal proxy as needed).

If the frontend and backend are both running in the same Replit project:

Configure the frontend to call the backend via the exposed Replit URL and correct path (e.g., https://<repl-name>.<user>.repl.co/api/...).

Do not hardcode localhost:<port> if that will not work in the deployed Replit environment; instead, use env variables and/or relative paths where appropriate.

8. Security expectations

All secrets (DB, Redis, Ola Maps, JWT, etc.) must be environment variables, never committed to git.

If you need to add example env variables, put them in a .env.example or documentation, not in .env committed to the repo.

Do not introduce any debug endpoints that expose sensitive data.

Do not enable CORS or auth-less behavior beyond what is already defined unless I explicitly request it.

9. What you should ask me before proceeding

After scanning the repo, you should come back to me with:

A list of:

Backend entry point(s) and suggested Replit run commands.

Worker/background processes and their run commands.

A clear list of all required environment variables, grouped as:

Supabase

Redis/Upstash

Maps (Ola)

Auth/security (JWT, SECRET_KEY, etc.)

Any other 3rd-party services found.

Confirmation of:

Backend port (and if it needs changing).

Frontend dev build/start commands.

How the frontend will reach the backend in Replit (base URL plan).

Only after presenting this summary to me and getting my input/credentials should you finalize the Replit configuration.